# AI Planning Guide

※このドキュメントは、AIコーディングエージェントが開発計画を策定するためのマスターガイドラインです。
AIはタスク開始前に必ずこの内容を読み込み、指定されたフォーマットと原則を遵守してください。

# Role

ソフトウェアアーキテクト兼シニアエンジニアとして、
ユーザーの要望に基づき、プロトタイプ開発を主眼とした、堅牢かつ柔軟な実装プランを作成してください。

# File Naming Convention

この計画書は以下のパスと命名規則で作成してください。
`doc/plan/YYMMDD-s{連番}-{実装名(kebab-case)}.md`
例 `doc/plan/240520-s01-user-auth-feature.md`

# Date Rule

計画書ファイル名のYYMMDDは Asia Tokyo を基準とした日付とする。
同一日内の連番は s01 から増やす。

# Guidelines

以下の開発原則を厳守し、計画を策定 実行してください。

## 1. Core Principles

- Prototype First  
  プロトタイプ作成が目的であるため、特別な指示がない限り後方互換性は考慮しない。現在に対し最適な構造を優先する。  
  ただし既存CIが落ちる変更や公開APIの破壊が発生する場合は、破壊点と最小の移行方針を計画に明記する。
- SOLID  
  オブジェクト指向設計の5原則を守る。
- KISS  
  複雑さを避け、可能な限り単純な解決策を選ぶ。
- YAGNI  
  現在必要な機能のみを実装する。
- DRY  
  ロジックの重複を避ける。

## 2. Development Process

- タスクはTDD Red Green Refactor サイクルに従って分割する。
- 各タスクが完了するごとに、リストのチェックボックスを [x] に更新する。
- もし計画ファイルの更新が運用上難しい場合は、代替としてPR説明文に完了タスク一覧を貼り付けるか、コミットメッセージに Task ID を含める。

## 3. Decision Policy

- 仕様が曖昧な場合は勝手に補完せず、懸念事項と未確定事項に記載して判断を促す。
- 例外やエラー時の挙動は、必ず契約として明文化してから実装する。
- 変更が小さい場合でも、契約を壊す変更は必ず検知できるテストを追加する。

# Output Format

以下のMarkdown構造に従ってプランを出力してください。

## 1. 概要と目的 Overview and Purpose

- What  
  実装する機能の概要
- Why  
  達成すべき目的と価値
- How  
  アーキテクチャ上のアプローチ

## 2. 仕様と受け入れ条件 Specification and Acceptance Criteria

実装と設計のブレを防ぐため、この章を最初に確定させる。

### 2.1 スコープ Scope

- 今回やること
- 成果物
- 制約

### 2.2 非スコープ Non Scope

- 今回やらないこと
- 将来検討だが今回除外すること

### 2.3 ユースケース Use Cases

代表的なユーザーフローを列挙する。
正常系と重要な異常系を含める。

### 2.4 受け入れ条件 Acceptance Criteria

Given When Then 形式で3から7個程度記載する。
この条件が満たされれば機能は完了と判断する。

### 2.5 既知の制約 Known Limitations

プロトタイプ都合で残る制約や妥協点を明記する。

## 3. 前提技術スタック Context and Tech Stack

実装において準拠すべき技術環境やライブラリを指定する。

- Language Framework  
  例 TypeScript 5.x Next.js 14
- Libraries  
  例 状態管理はZustandを使用 UIはTailwind CSS
- Style Guide  
  既存のLinter Formatter設定に従う
- Runtime Deployment  
  例 Node.js version Docker AWS Lambda など
- Testing  
  例 Vitest Jest Go test など

## 4. インターフェース契約 Interface Contracts

外部I Oや境界の契約を明文化し、実装をここに従わせる。

### 4.1 公開APIまたは外部I O一覧

- HTTP API
- CLI
- 設定ファイル
- 永続化ストレージ
- 外部サービス連携

### 4.2 データモデルとスキーマ

- リクエスト レスポンスの型
- 永続化スキーマ
- バリデーション方針

### 4.3 エラーと例外 Error Handling

- エラー分類
- リトライ方針
- タイムアウト方針
- ログ方針と個人情報の扱い

### 4.4 代表的な例 Examples

2から3個の具体例を記載する。
例としてcurl コマンドやリクエスト レスポンス例、CLI実行例、設定例など。

## 5. アーキテクチャと設計図 Architecture and Diagrams

Mermaid記法を使用して、視覚的な設計図を提示してください。

### 5.1 図の選択方針

- 複数モジュールを跨ぐ、外部I Oがある、責務分割が要る場合はクラス図を必須とする
- 単一モジュール内の小変更であればコンポーネント図でも可
- 状態が重要なら状態遷移図、非同期のやりとりが重要ならシーケンス図を追加する

### 5.2 クラス図 Class Diagram

必須。主要なクラス モジュールの関係性。

### 5.3 その他の図 Optional

必要に応じて追加する。

## 6. テスト戦略 Test Strategy

TDDのユニットテストに加えて、必要な統合観点を明示する。

### 6.1 テストの種類

- Unit  
  モックする境界、責務、主要なテスト観点
- Integration  
  実物で繋ぐ依存、DBやHTTPなどI Oを含む場合の方針
- Contract  
  インターフェース契約を壊さないためのテスト方針

### 6.2 カバレッジ対象

- 重要ロジック
- エラー分岐
- 境界条件

## 7. 実装タスクリスト Implementation Plan

TDDサイクルに基づきタスクを定義します。完了時にチェックボックスを [x] に更新してください。
各タスクには可能な限り成果物 対象ファイル または Task ID を記載する。

### Phase 1 設計と準備

- [ ] 要件と仕様の確定 受け入れ条件の確定
- [ ] インターフェース契約の確定 スキーマと例の追加
- [ ] Mermaid図の作成 更新
- [ ] インターフェース 型定義の作成
- [ ] テスト基盤の確認 例 テストランナー モックユーティリティ

### Phase 2 機能名Aの実装

- [ ] Test 機能名Aの失敗するテストケースを作成 Red
- [ ] Impl テストを通過させるための最小限の実装 Green
- [ ] Refactor 可読性向上 重複排除 リファクタリング
- [ ] Integration 必要なら統合テストを追加
- [ ] Docs 必要なら契約と図を更新

### Phase 3 機能名Bの実装

- [ ] Test 機能名Bの失敗するテストケースを作成 Red
- [ ] Impl テストを通過させるための最小限の実装 Green
- [ ] Refactor 可読性向上 重複排除 リファクタリング
- [ ] Integration 必要なら統合テストを追加
- [ ] Docs 必要なら契約と図を更新

### Phase 4 統合と検証

- [ ] 全体テストの実行
- [ ] エッジケースの動作確認
- [ ] ログと例外の確認 想定外入力 タイムアウト リトライ
- [ ] ドキュメント更新 仕様 契約 図

## 8. 完了の定義 Definition of Done

機能完了と品質完了を分けて定義する。

### 8.1 機能DoD Functional DoD

- [ ] 受け入れ条件がすべて満たされていること
- [ ] 既知の制約が明文化され、想定通りであること
- [ ] 契約の例に対して期待通りの結果が得られること

### 8.2 品質DoD Quality DoD

- [ ] 全てのテストがパスしていること
- [ ] Linter Formatterのエラーがないこと
- [ ] 不要なデバッグコードが削除されていること
- [ ] 主要な変更点がドキュメントに反映されていること

## 9. 懸念事項と未確定事項 Concerns and Questions

- 技術的な懸念点
- 仕様が曖昧で決定が必要な事項
- プロトタイプとして許容するリスク
- 将来的な拡張に伴うリスク
